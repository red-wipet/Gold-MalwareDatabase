#pragma once
#define _USE_MATH_DEFINES 1
#include <windows.h>
#include <windef.h>
#include <winnt.h>
#include <math.h>
#include <stdlib.h>
#include <winternl.h>
#define _USE_MATH_DEFINES 1
#define PAYLOAD_TIME 20
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <mmsystem.h>
#include <iostream>
#pragma  comment(lib,"msimg32.lib")
#pragma comment(lib, "winmm.lib")

typedef union _RGBQUAD
{
	COLORREF rgb;
	struct
	{
		BYTE b;
		BYTE g;
		BYTE r;
		BYTE unused;
	};
}
*PRGBQUAD;

typedef void(payload)(int t, HDC hdcScreen);
typedef void(shader)(int t, int w, int h, PRGBQUAD prgbScreen);

int RotateDC(HDC hdc, int Angle, POINT ptCenter)
{
	int nGraphicsMode = SetGraphicsMode(hdc, GM_ADVANCED);
	XFORM xform;
	if (Angle != 0)
	{
		double fangle = (double)Angle / 180. * 3.1415926;
		xform.eM11 = (float)cos(fangle);
		xform.eM12 = (float)sin(fangle);
		xform.eM21 = (float)-sin(fangle);
		xform.eM22 = (float)cos(fangle);
		xform.eDx = (float)(ptCenter.x - cos(fangle) * ptCenter.x + sin(fangle) * ptCenter.y);
		xform.eDy = (float)(ptCenter.y - cos(fangle) * ptCenter.y - sin(fangle) * ptCenter.x);
		SetWorldTransform(hdc, &xform);
	}
	return nGraphicsMode;
}

extern RECT GetVirtualScreen();
extern BOOL CALLBACK MonitorEnumProc(HMONITOR hMonitor, HDC hdcMonitor, PRECT prcBounds, LPARAM lParam);
extern POINT GetVirtualScreenPos();
extern SIZE GetVirtualScreenSize();
extern void rand(DWORD dwSeed);
extern void ExecuteShader(shader shader, int nTime);
extern void Shader1(int t, int w, int h, PRGBQUAD prgbScreen);
extern DWORD Time;
extern void InitTimer(UINT uDelay);
extern void CALLBACK TimerProc(HWND hwndTimer, UINT uMsg, UINT_PTR ulTimerID, DWORD dwTime);

RECT GetVirtualScreen()
{
	RECT rcScreen = { 0 };
	EnumDisplayMonitors(NULL, NULL, MonitorEnumProc, (LPARAM)&rcScreen);
	return rcScreen;
}
POINT GetVirtualScreenPos()
{
	RECT rcScreen = GetVirtualScreen();
	POINT ptScreen =
	{
		rcScreen.left,
		rcScreen.top
	};
	return ptScreen;
}
SIZE GetVirtualScreenSize()
{
	RECT rcScreen = GetVirtualScreen();
	SIZE szScreen =
	{
		rcScreen.right - rcScreen.left,
		rcScreen.bottom - rcScreen.top
	};
	return szScreen;
}
BOOL CALLBACK MonitorEnumProc(HMONITOR hMonitor, HDC hdcMonitor, PRECT prcBounds, LPARAM lParam)
{
	PRECT prcParam = (RECT*)lParam;
	UnionRect(prcParam, prcParam, prcBounds);
	return true;
}

DWORD Time;
void InitTimer(UINT uDelay)
{
	UINT_PTR id = SetTimer(NULL, 0, uDelay, TimerProc);
	MSG msg = { 0 };
	while (true)
	{
		if (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}
}
void CALLBACK TimerProc(HWND hwndTimer, UINT uMsg, UINT_PTR ulTimerID, DWORD dwTime)
{
	Time++;
}